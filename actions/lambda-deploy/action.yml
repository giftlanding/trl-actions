name: 'Deploy Lambda Function'
description: 'Build Node.js applications and deploy them to AWS Lambda'
author: 'Your Organization'

inputs:
  node-version:
    description: 'Node.js version to use'
    required: false
    default: '22'
  
  aws-region:
    description: 'AWS region for Lambda deployment'
    required: false
    default: 'us-east-1'
  

  
  function-name:
    description: 'Lambda function name (defaults to repository name)'
    required: false
  
  build-command:
    description: 'Build command to run (defaults to npm run build)'
    required: false
    default: 'npm run build'
  
  source-dir:
    description: 'Source directory for compiled code (defaults to dist)'
    required: false
    default: 'dist'
  
  package-dir:
    description: 'Directory to create deployment package in (defaults to package)'
    required: false
    default: 'package'
  
  force-rebuild:
    description: 'Force rebuild by invalidating cache'
    required: false
    default: 'false'
  
  arm-native:
    description: 'Build native ARM64 binaries using Docker'
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}
        cache: 'npm'
    
    - name: Install dependencies
      shell: bash
      run: npm ci
    
    - name: Configure webpack for native dependencies (if ARM64)
      if: inputs.arm-native == 'true'
      shell: bash
      run: |
        # Check if webpack.config.js exists and add native dependencies to externals
        if [ -f webpack.config.js ]; then
          echo "Configuring webpack for ARM64 native dependencies..."
          
          # Get list of native dependencies from package.json
          NATIVE_DEPS=$(node -e "
            const pkg = require('./package.json');
            const deps = { ...pkg.dependencies, ...pkg.devDependencies };
            const nativeDeps = Object.keys(deps).filter(dep => {
              try {
                const depPkg = require(dep + '/package.json');
                return depPkg.binary || depPkg.gypfile || depPkg.scripts && 
                       (depPkg.scripts.install || depPkg.scripts.rebuild);
              } catch (e) {
                return false;
              }
            });
            console.log(nativeDeps.join(','));
          " 2>/dev/null || echo '')
          
          if [ -n "$NATIVE_DEPS" ]; then
            echo "Found native dependencies: $NATIVE_DEPS"
            
            # Add each native dependency to webpack externals
            for dep in $(echo "$NATIVE_DEPS" | tr ',' ' '); do
              if [ -n "$dep" ] && ! grep -q "'$dep': '$dep'" webpack.config.js; then
                echo "Adding $dep to webpack externals..."
                sed -i "s/externals: {/externals: {\n    '$dep': '$dep',/" webpack.config.js
              fi
            done
          fi
        fi
    
    - name: Setup Docker (if needed)
      if: inputs.arm-native == 'true'
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          image=moby/buildkit:latest
    
    - name: Enable QEMU (if needed)
      if: inputs.arm-native == 'true'
      uses: docker/setup-qemu-action@v3
      with:
        platforms: linux/arm64
    
    - name: Cache npm (if using Docker)
      if: inputs.arm-native == 'true'
      uses: actions/cache@v4
      with:
        path: .npm
        key: ${{ runner.os }}-node${{ inputs.node-version }}-arm64-npm-${{ hashFiles('package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node${{ inputs.node-version }}-arm64-npm-
    
    - name: Cache Docker layers (if using Docker)
      if: inputs.arm-native == 'true'
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-
    
    - name: Build TypeScript (if not using Docker)
      if: inputs.arm-native != 'true'
      shell: bash
      run: ${{ inputs.build-command }}
    
    - name: Create Dockerfile for ARM64 build
      if: inputs.arm-native == 'true'
      shell: bash
      run: |
        # Always build fresh (no webpack cache)
        echo "Building fresh webpack output"
        cat > Dockerfile << 'EOF'
        FROM public.ecr.aws/lambda/nodejs:${{ inputs.node-version }}
        
        # Install zip utility and git
        RUN command -v dnf && dnf install -y zip git || yum -y install zip git
        
        # Set environment variables for ARM64 builds
        ENV SHARP_IGNORE_GLOBAL_LIBVIPS=1
        ENV npm_config_platform=linux
        ENV npm_config_arch=arm64
        
        # Set working directory
        WORKDIR /var/task
        
        # Copy package files first for better caching
        COPY package*.json ./
        
        # Install dependencies with proper ARM64 native binaries
        RUN npm config set cache /var/task/.npm --prefer-offline && \
            npm ci --include=optional && \
            # Rebuild all native dependencies for ARM64
            npm rebuild --platform=linux --arch=arm64 --target=${{ inputs.node-version }}.0
        
        # Copy source files and cached build output
        COPY . .
        
        # Use cached build output instead of rebuilding
        RUN mkdir -p package && \
            cp -r ${{ inputs.source-dir }}/* package/ && \
            cp package*.json package/ && \
            cd package && \
            npm ci --omit=dev && \
            # Ensure native dependencies are properly installed in final package
            npm rebuild --platform=linux --arch=arm64 --target=${{ inputs.node-version }}.0 && \
            zip -r ../function.zip . && \
            cd .. && \
            chmod a+r function.zip
        
        CMD ["/bin/bash"]
        EOF
        else
          echo "No cached build output, will build from source"
          cat > Dockerfile << 'EOF'
        FROM public.ecr.aws/lambda/nodejs:${{ inputs.node-version }}
        
        # Install zip utility and git
        RUN command -v dnf && dnf install -y zip git || yum -y install zip git
        
        # Set environment variables for ARM64 builds
        ENV SHARP_IGNORE_GLOBAL_LIBVIPS=1
        ENV npm_config_platform=linux
        ENV npm_config_arch=arm64
        
        # Set working directory
        WORKDIR /var/task
        
        # Copy package files first for better caching
        COPY package*.json ./
        
        # Install dependencies with proper ARM64 native binaries
        RUN npm config set cache /var/task/.npm --prefer-offline && \
            npm ci --include=optional && \
            # Rebuild all native dependencies for ARM64
            npm rebuild --platform=linux --arch=arm64 --target=${{ inputs.node-version }}.0
        
        # Copy source files
        COPY . .
        
        # Build the function
        RUN ${{ inputs.build-command }} && \
            mkdir -p package && \
            cp -r ${{ inputs.source-dir }}/* package/ && \
            cp package*.json package/ && \
            cd package && \
            npm ci --omit=dev && \
            # Ensure native dependencies are properly installed in final package
            npm rebuild --platform=linux --arch=arm64 --target=${{ inputs.node-version }}.0 && \
            zip -r ../function.zip . && \
            cd .. && \
            chmod a+r function.zip
        
        CMD ["/bin/bash"]
        EOF
        fi
        
        echo "Created Dockerfile for ARM64 build"
    
    - name: Build with Docker (if using Docker)
      if: inputs.arm-native == 'true'
      shell: bash
      run: |
        # Create cache key based on dependencies and source code using input patterns
        CACHE_KEY="lambda-build-${{ hashFiles('package-lock.json', inputs.cache-key-patterns) }}"
        echo "Using cache key: $CACHE_KEY"
        
        # Build with Docker using Lambda ARM64 container
        docker buildx build --platform linux/arm64 \
          --cache-from type=local,src=/tmp/.buildx-cache \
          --cache-from type=gha \
          --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
          --cache-to type=gha,mode=max \
          --load \
          --tag lambda-builder \
          --progress=plain \
          . || {
            echo "Cache build failed, trying without cache..."
            docker buildx build --platform linux/arm64 \
              --load \
              --tag lambda-builder \
              --progress=plain \
              .
          }
        
        # Move cache to final location
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache
        
        # Extract the function.zip from the built image
        docker create --name temp-container lambda-builder
        docker cp temp-container:/var/task/function.zip ./function.zip
        docker rm temp-container
        
        echo "Build complete. Function size: $(ls -lh function.zip | awk '{print $5}')"
        
        # Save webpack build output for caching if it was built from source
        if [ ! -d "${{ inputs.source-dir }}" ] || [ ! "$(ls -A ${{ inputs.source-dir }} 2>/dev/null)" ]; then
          echo "Extracting build output for caching..."
          docker create --name extract-container lambda-builder
          docker cp extract-container:/var/task/${{ inputs.source-dir }} ./${{ inputs.source-dir }}
          docker rm extract-container
          echo "Build output extracted for future caching"
        fi
        
        # Verify native dependencies if any were detected
        if [ -f webpack.config.js ]; then
          echo "Verifying native dependencies in built package..."
          
          # Create temporary container to check native dependencies
          docker create --name verify-container lambda-builder
          
          # Check for common native dependency patterns
          NATIVE_DEPS=$(node -e "
            const pkg = require('./package.json');
            const deps = { ...pkg.dependencies, ...pkg.devDependencies };
            const nativeDeps = Object.keys(deps).filter(dep => {
              try {
                const depPkg = require(dep + '/package.json');
                return depPkg.binary || depPkg.gypfile || depPkg.scripts && 
                       (depPkg.scripts.install || depPkg.scripts.rebuild);
              } catch (e) {
                return false;
              }
            });
            console.log(nativeDeps.join(','));
          " 2>/dev/null || echo '')
          
          if [ -n "$NATIVE_DEPS" ]; then
            echo "Verifying native dependencies: $NATIVE_DEPS"
            
            for dep in $(echo "$NATIVE_DEPS" | tr ',' ' '); do
              if [ -n "$dep" ]; then
                # Check if the native dependency has ARM64 binaries
                if docker exec verify-container test -d "/var/task/package/node_modules/$dep/build/Release" 2>/dev/null; then
                  echo "✅ $dep: ARM64 binaries found"
                elif docker exec verify-container test -d "/var/task/package/node_modules/$dep/build" 2>/dev/null; then
                  echo "✅ $dep: Build directory found"
                else
                  echo "⚠️  $dep: No build directory found (may be pure JS)"
                fi
              fi
            done
          fi
          
          docker rm verify-container
        fi
    
    - name: Cache deployment package (if not using Docker)
      if: 'false'
      uses: actions/cache@v4
      id: package-cache
      with:
        path: |
          ${{ inputs.package-dir }}
          function.zip
        key: ${{ runner.os }}-package-${{ hashFiles('package-lock.json', inputs.cache-key-patterns) }}
        restore-keys: |
          ${{ runner.os }}-package-${{ hashFiles('package-lock.json') }}-
    
    - name: Create deployment package (if not using Docker)
      if: inputs.arm-native != 'true' && (inputs.force-rebuild == 'true' || steps.package-cache.outputs.cache-hit != 'true')
      shell: bash
      run: |
        # Create a temporary directory for the package
        mkdir -p ${{ inputs.package-dir }}
        
        # Copy compiled JavaScript from source directory
        cp -r ${{ inputs.source-dir }}/* ${{ inputs.package-dir }}/
        
        # Copy package.json and package-lock.json
        cp package.json ${{ inputs.package-dir }}/
        cp package-lock.json ${{ inputs.package-dir }}/
        
        # Install production dependencies
        cd ${{ inputs.package-dir }}
        npm ci --omit=dev
        cd ..
        
        # Create the zip file
        cd ${{ inputs.package-dir }}
        zip -r ../function.zip .
        cd ..
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::649006552804:role/${{ github.event.repository.name }}-update-code
        aws-region: ${{ inputs.aws-region }}
    
    - name: Update Lambda function
      shell: bash
      run: |
        FUNCTION_NAME="${{ inputs.function-name || github.event.repository.name }}"
        aws lambda update-function-code \
          --function-name "$FUNCTION_NAME" \
          --zip-file fileb://function.zip
    
    - name: Verify deployment
      shell: bash
      run: |
        FUNCTION_NAME="${{ inputs.function-name || github.event.repository.name }}"
        aws lambda get-function \
          --function-name "$FUNCTION_NAME" \
          --query 'Configuration.LastUpdateStatus' \
          --output text
